{
  "hash": "c6500f4607bda566b928197e1d71e313",
  "result": {
    "markdown": "---\nauthor: David Schoch \ncategories:\n- network analysis\ndescription: Network Analysis in R using tidygraph\ntitle: \"Tidy Network Analysis in R\"\nsubtitle: \"using the tidygraph package\"\nimage: featured.png\npriority: 3\ntoc: true\ntitle-block-style: none\n---\n\n\n\n\n(last update 2022-09-26)\n\n# Introduction\n\nThe main focus of this tutorial is to introduce the tidy approach for network analysis.\nFor a general and more basic introduction to network analysis in R, see my [dedicated tutorial](https://www.mr.schochastics.net/material/netanar/). The tutorial will focus on the most\nrelevant functions for empirical research. A more complete overview of the complete functionality can be found\n[here](https://www.data-imaginist.com/2017/introducing-tidygraph/).\n\n# Required libraries\n\nTo run all the code in this tutorial, you need to install and load two packages.\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidygraph\")\ndevtools::install_github(\"schochastics/networkdata\")\n```\n:::\n\n\n`tidygraph` implements the tidy approach for network analysis. `networkdata` contains a diverse set of\nnetwork dataset. To reproduce the figures in the tutorial, you will also need `ggraph`. For help with network visualization, see [this tutorial](https://www.mr.schochastics.net/material/netvizr/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidygraph)\nlibrary(networkdata)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nMake sure you have at least the version given below. Some of the examples may not be backward compatible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"tidygraph\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '1.2.2'\n```\n:::\n\n```{.r .cell-code}\npackageVersion(\"networkdata\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '0.1.14'\n```\n:::\n:::\n\n\n# What is tidy network data?\n\nOn first glance, there is not much tidiness in networks or the ways it is usually encoded, like a \ngraph, adjacency matrix, edgelist, etc. How should this fit into a single data frame? If you are an avid\n`igraph` user, then you may suspect the answer. It doesn't fit, but it fits in two with `graph_from_data_frame()` which takes two data frames, one for nodes and one for edges, as input. In other words, we can represent \na network as two separate data frames. One for the nodes and node attributes, and one for the edges and edge attributes. Working with these two data frames together is the premise for the `tidygraph` package.\nIf you are interested in more technical details on how this is implemented under the hood, see the [introductory blog post](https://www.data-imaginist.com/2017/introducing-tidygraph/) for the package.\n\n# Why tidy network data?\n\nThis is a good question. If you aren't a fan of the tidyverse, then you should probably move along and\nstick with established packages such as `igraph` or `sna` which offer the exact same functionalities (`tidygraph` actually imports most of `igraph`). If you appreciate the tidyverse, then there is no need \nfor convincing you that this is a good idea. If you are indifferent, then I hope I can make a case \nfor the tidy framework below. To start off with, the package does a great job to harmonize many network analytic tasks. For instance, you do not need to know all the different centrality indices that are implemented. You simply type `centrality_` and press tab in the RStudio console and get all functions that allow the calculation of a \ncentrality index. Other node level functions are accessible via `node_*()` and edge level measures via `edge_*()`.\n\n# The Basics\n\n## Graph structures\nWe'll use the famous Florentine Family marriage dataset as a running example. The\ndataset is in `igraph` format but can be converted to a `tbl_graph` object with \n`as_tbl_graph()`. \n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"flo_marriage\")\nflo_tidy <- as_tbl_graph(flo_marriage)\nflo_tidy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tbl_graph: 16 nodes and 20 edges\n#\n# An undirected simple graph with 2 components\n#\n# Node Data: 16 × 4 (active)\n  name       wealth `#priors` `#ties`\n  <chr>       <dbl>     <dbl>   <dbl>\n1 Acciaiuoli     10        53       2\n2 Albizzi        36        65       3\n3 Barbadori      55         0      14\n4 Bischeri       44        12       9\n5 Castellani     20        22      18\n6 Ginori         32         0       9\n# … with 10 more rows\n#\n# Edge Data: 20 × 2\n   from    to\n  <int> <int>\n1     1     9\n2     2     6\n3     2     7\n# … with 17 more rows\n```\n:::\n:::\n\nThis new graph class just subclasses `igraph` and simply represents the network in a tidy fashion, printing two data frames, one for nodes and one for edges.\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(flo_tidy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_graph\" \"igraph\"   \n```\n:::\n:::\n\nAny function in R that expects an `igraph` object as input will also accept a `tbl_graph`.\n\nThe function `tbl_graph()` can be used to create a network from scratch with two data frames.\nIt is basically equivalent to `graph_from_data_frame()`. \n\nTo create random graphs with the usual generators, check out the `create_*()` and `play_*()` families of functions.\n\n## Standard verbs\n\nThe tidy framework, specifically thinking about `dplyr`, is about providing verbs which help to\nsolve common data manipulation tasks, such as `mutate()`, `select()`, `filter()`, and\n`summarise()`. The challange for the `tbl_graph` objects is that these verbs somehow need to work with two \ndifferent data frames. The way `tidygraph` solves this is via a pointer to the data frame which is supposed to be manipulated. This pointer can be changed with the verb `activate()`. By default the nodes are activated, which can also be seen with the print function (see line 5 in the output of flo_tidy). To activate the edge data frame, simply use `activate(\"edges\")`.\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy %>% activate(\"edges\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tbl_graph: 16 nodes and 20 edges\n#\n# An undirected simple graph with 2 components\n#\n# Edge Data: 20 × 2 (active)\n   from    to\n  <int> <int>\n1     1     9\n2     2     6\n3     2     7\n4     2     9\n5     3     5\n6     3     9\n# … with 14 more rows\n#\n# Node Data: 16 × 4\n  name       wealth `#priors` `#ties`\n  <chr>       <dbl>     <dbl>   <dbl>\n1 Acciaiuoli     10        53       2\n2 Albizzi        36        65       3\n3 Barbadori      55         0      14\n# … with 13 more rows\n```\n:::\n:::\n\nAny data manipulation would now be done on the edge data frame. \n\nHaving \"activated\" a data frame, many of the known dplyr verbs can be used to manipulate the \ndata frame. The activation process might indicate that edges and nodes can only be manipulated separately, which is certainly not desirable. It is, however, possible to gain access to the edge data frame when nodes are activated via the `.E()`. Similarly, nodes can be accessed via `.N()` when edges are activated.\nIn the below example, we activate the edges and create a new edge attribute which indicates if a family\nis connected to the Medici or not.\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy <- flo_tidy %>% \n  activate(\"edges\") %>% \n  mutate(to_medici=(.N()$name[from]==\"Medici\" | .N()$name[to]==\"Medici\"))\n```\n:::\n\nThis particular use case is helpful for visualizations. \n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(flo_tidy,\"stress\") + \n  geom_edge_link0(aes(edge_color = to_medici))+\n  geom_node_point(shape = 21, size = 10, fill = \"grey66\")+\n  geom_node_text(aes(label = name))+\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/connect_medici_plot-1.png){width=100%}\n:::\n:::\n\n\nThe `dplyr` verb `filter()` can be used to obtain a subgraph that satisfies given conditions on the nodes.\nNote that in the case that you filter on nodes, also edges will be effected. If a node does not satisfy the\ncondition, then all edges connected to that node disappear. This is not the case for edges though.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy %>% \n  activate(\"edges\") %>% \n  filter(to_medici) %>% \nggraph(\"stress\",bbox=10) + \n  geom_edge_link0(edge_color = \"black\")+\n  geom_node_point(shape = 21, size = 10, fill = \"grey66\")+\n  geom_node_text(aes(label = name))+\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/filter_example-1.png){width=100%}\n:::\n:::\n\n\n## Joins\n\n## New Verbs\n\n\n# Centrality\nThe package includes all centrality indices implemented in `igraph` and additionally all \nthat are made available in the `netrankr` package. All indices can be found in the \nfunction group `centrality_*()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflo_tidy %>% \n  activate(\"nodes\") %>% \n  mutate(degree = centrality_degree(),\n         betweenness = centrality_betweenness()) %>% \nggraph(\"stress\",bbox=10) + \n  geom_edge_link0(edge_color = \"black\")+\n  geom_node_point(shape = 21, aes(size=degree,fill=betweenness))+\n  geom_node_text(aes(label = name))+\n  scale_fill_gradient(low=\"#104E8B\",high=\"#CD2626\")+\n  scale_size(range = c(4,10))+\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/centrality_example-1.png){width=100%}\n:::\n:::\n\n\n\n# Clustering\n\nSimilar to centrality, all clustering algorithms from `igraph` are available via `group_*()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create random graph with group structure (igraph equivalent is sample_islands())\nplay_islands(4, 12, 0.8, 4) %>% \n    mutate(community = as.factor(group_louvain())) %>% \n    ggraph(layout = 'stress') + \n    geom_edge_link0() + \n    geom_node_point(aes(fill = community), shape = 21, size = 6) + \n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/clustering_example-1.png){width=100%}\n:::\n:::\n\n\nCoupling this with what we learned above, we can color the edges according to the cluster\nthey belong to.\n\n::: {.cell}\n\n```{.r .cell-code}\nplay_islands(4, 12, 0.8, 4) %>% \n  mutate(community = as.factor(group_louvain())) %>% \n  activate(\"edges\") %>% \n  mutate(community = as.factor(ifelse(.N()$community[from]==.N()$community[to],.N()$community[from],5))) %>% \n  ggraph(layout = 'stress') + \n  geom_edge_link0(aes(edge_colour=community),show.legend = FALSE) + \n  geom_node_point(aes(fill = community), shape = 21, size = 6) + \n  scale_fill_brewer(palette = \"Set3\")+\n  scale_edge_color_brewer(palette = \"Set3\")+\n  theme_graph(background = \"grey88\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/clustering_example2-1.png){width=100%}\n:::\n:::\n\n\n# Other node or edge level functions\n\n`tidygraphs` harmonizes many other available functions in igraph to make them easier accessible.\nThe best way to check what is available is to look at the function groups `node_*()` and `edge_*()`.\nSome simple examples are shown below.\n\n::: {.cell}\n\n```{.r .cell-code}\n# the node id of the Medici is 9\nflo_tidy %>% \n  activate(\"nodes\") %>% \n  mutate(dist2Medici = node_distance_to(nodes = 9)) %>% \n  activate(\"edges\") %>% \n  mutate(edge2Medici = edge_is_incident(i = 9)) %>% \n  ggraph(\"stress\") + \n  geom_edge_link0(aes(edge_color = edge2Medici))+\n  geom_node_point(aes(fill = dist2Medici),size = 9,shape = 21)+\n  theme_graph()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/distance_to_medici-1.png){width=100%}\n:::\n:::\n\n\n\n# Shortcomings\n\nThe tidy framework works well in general but there are some shortcomings. So far, only\nbasic network analytic methods are supported. This is enough for many tasks but as soon as more \nadvanced techniques are needed, you are forced to switch to the \"untidy\" way again. A lot of \ncoding but also conceptual work is needed to advance the framework further. For instance, how do ERGMs or SAOMs fit into this? Maybe there is a way to use `tidymodels`, but that is beyond the scope for now.\n\n# Further Reading\n<!-- See [here](https://www.data-imaginist.com/2017/introducing-tidygraph/) for a brief introduction to `tidygraph` by its maintainer Thomas Lin Pedersen    -->\n\n<!-- There is an [Rview](https://rviews.rstudio.com/2019/03/06/intro-to-graph-analysis/) post by Edgar Ruiz   -->\n\n<!-- [Network analysis in R](https://www.jessesadler.com/post/network-analysis-with-r/) by Jesse Sadler   -->\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}