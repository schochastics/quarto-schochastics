{
  "hash": "38af3abb437ebf0aae699055b8492a4f",
  "result": {
    "markdown": "---\nauthor: David Schoch \ncategories:\n- network analysis\ndescription: Tutorial for Network Analysis in R\ntitle: \"Basic Network Analysis in R\"\nsubtitle: \"using igraph and related packages\"\npriority: 2\nimage: featured.png\ntoc: true\ntitle-block-style: none\ncomments:\n  utterances:\n    repo: schochastics/quarto-schochastics\n    issue-term: pathname\n    label: comment\n    theme: photon-dark\n---\n\n\n\n\n(last update 2022-09-26)\n\n# Introduction\n\nThe main focus of this tutorial is empirical analysis of networks and skips a lot of additional functionality of igraph\nFor the most part of this tutorial, we assume that the network data is already present in R.\nReading in data may not pose much of an issue if you are already familiar with R, but can be quite a\nchallenge if you are new to R. The last section of this tutorial is devoted to this topic in great detail. \n\nThe tutorial does introduce key terms for network analysis, but much of the theory behind them is not explained in great detail. This tutorial is meant to be \"hands-on\", giving practical help for empirical \nwork. If you are interested in the technical/theoretical details behind certain methods, please consult \nrelevant literature (a list is given at the end of the tutorial).\n\n# Required libraries\n\nTo run all the code in this tutorial, you need to install and load three packages.\n\n::: {.cell hash='index_cache/html/install_libraries_8d96f59eea0356903bd8c504511aae4a'}\n\n```{.r .cell-code}\ninstall.packages(c(\"igraph\",\"netrankr\"))\ndevtools::install_github(\"schochastics/networkdata\")\n```\n:::\n\n\n`igraph` is used for the majority of analytic tasks and for its data structures. `netrankr` is a package\nfor network centrality. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(netrankr)\nlibrary(networkdata)\n```\n:::\n\n::: {.cell hash='index_cache/html/silent_libraries_d6afceaf50d9a1a1fdbea004b30a4fa1'}\n\n:::\n\n\nMake sure you have at least the version given below. Some of the examples may not be backward compatible.\n\n\n::: {.cell hash='index_cache/html/pkg_version_check_cbe36838216e3bc9f2f2de9860f6e56d'}\n\n```{.r .cell-code}\npackageVersion(\"igraph\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '1.3.1'\n```\n:::\n\n```{.r .cell-code}\npackageVersion(\"netrankr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '1.1.1'\n```\n:::\n\n```{.r .cell-code}\npackageVersion(\"networkdata\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '0.1.11'\n```\n:::\n:::\n\n\n---\n\n# Which package to choose?\n\nWell, the last section spoiled already what we are going to use in this tutorial, but for the \nsake of completeness, I will discuss some other packages here and motivate why I would recommend \n`igraph` as the goto package for standard network analytic tasks.\n\nBesides methods, `igraph` also provides data structures which facilitate to store and process network data. Two other packages \nthat allow for this are `graph` and `network`. The former is, however, not available on CRAN anymore, only via\nBioconductor. The latter provides the foundation for much of the statistical modelling aspects for networks such as\nExponential Random Graph Models (ERGMs) and Stochastic Actor Oriented Models (SAOMs).\n\nThe figure below shows how many packages on CRAN rely on those three packages (i.e. they are mentioned in `Depends`, `Imports`, or `Suggests`).\n\n::: {.cell hash='index_cache/html/crannet_depend_fbb1548adbf91cb4892b5a87402c6abc'}\n::: {.cell-output-display}\n![](index_files/figure-html/crannet_depend-1.png){width=100%}\n:::\n:::\n\n\nThe figure was produced with the help of the `cranet` package ([link](https://github.com/mbojan/cranet)).\n`igraph` seems to be clearly favored by the R community. So if you install a package for, say, signed network analysis,\nchanges are high that it depends on the graph structures provided by `igraph`. Besides the data structures,\nthe package offers a large variety of network analytic methods which are all implemented in C. The methods are well optimized and\nalso work quite well for large graphs. \n\nThe `network` package historically shares some commonalities with `igraphs` data structures. The package itself, though is really only providing the data structure and no analytic methods. The `sna` package ([link](https://cran.r-project.org/package=sna)) implements network analytic tools using the data structures provided by `network`.\nOverall, the syntax and provided methods are very much comparable between `igraph` and `sna` and they are almost interchangeable in this regard. The advantage of igraph is its speed. I have run several benchmark tasks and `igraph` usually comes out on top. That being said, there is no real case to be made against `network`/`sna`. If you are into statistical modelling of networks, then that should actually be the preferred choice since the `ergm` package is build on top of `network`. In this case you probably also\nwant to look at the meta package `statnet` ([link](http://statnet.org/)) which includes `network`, `sna`, and `ergm` (among other packages).\n\nThe package `intergraph` ([link](https://cran.r-project.org/package=intergraph)) can be used if you need to switch representations between `igraph` and `network`.\n\n\n---\n\n# Basic network notations\n\nNetworks are commonly represented with an **adjacency matrix** or via an **edgelist**. If you are interested \nin a \"tidy way\" checkout my [tidygraph](../tidynetAnaR/) tutorial. Below, we represent friendship relations between Bob, Ann, and Steve as a matrix and an edgelist.\n\n::: {.cell hash='index_cache/html/simple_struc_12f757fffe3227aca3a098b4eba43f24'}\n\n```{.r .cell-code}\n# adjacency matrix\nA <- matrix(c(0,1,1,1,0,1,1,1,0),nrow = 3,ncol = 3,byrow = TRUE)\nrownames(A) <- colnames(A) <- c(\"Bob\",\"Ann\",\"Steve\")\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Bob Ann Steve\nBob     0   1     1\nAnn     1   0     1\nSteve   1   1     0\n```\n:::\n\n```{.r .cell-code}\n#edge list\nel <- matrix(c(\"Bob\",\"Ann\",\"Bob\",\"Steve\",\"Ann\",\"Steve\"),\n             nrow = 3,ncol = 2, byrow = TRUE)\nel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]  [,2]   \n[1,] \"Bob\" \"Ann\"  \n[2,] \"Bob\" \"Steve\"\n[3,] \"Ann\" \"Steve\"\n```\n:::\n:::\n\nThe adjacency matrix $A$ is symmetric, meaning that the relations are undirected, i.e. Bob is friends with\nAnn and Ann is friends with Bob. In general, $A[i,j]=1$, if there is a relation between $i$ and $j$.\nIf $A[i,j]=1$ does not imply $A[j,i]=1$ then $A$ defines a directed network.\n\nOnce we have defined an edgelist or an adjacency matrix, we can turn them into `igraph` objects\nas follows.\n\n\n::: {.cell hash='index_cache/html/simple_graph_9fa69fdbcf2713900372714380d97705'}\n\n```{.r .cell-code}\ng1 <- graph_from_adjacency_matrix(A, mode = \"undirected\", diag = FALSE)\ng2 <- graph_from_edgelist(el,directed = FALSE)\n#g1 and g2 are the same graph so only printing g1\ng1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 792b086 UN-- 3 3 -- \n+ attr: name (v/c)\n+ edges from 792b086 (vertex names):\n[1] Bob--Ann   Bob--Steve Ann--Steve\n```\n:::\n:::\n\nThe printed summary shows some general descriptives of the graph.\nThe string \"UN--\" in the first line indicates that the network is *U*ndirected (*D* for directed graphs) and has a *N*ame attribute (we named the nodes Bob, Ann, and Steve). The third and forth character are *W*, if there is a edge weight attribute, and *B* if the network is bipartite (there exists a node attribute \"type\"). The following number indicate the number of nodes and edges.\nThe second line lists all graph, node and edge variables. Here, we only have a node attribute \"name\". \n\nThe conversion from edgelist/adjacency matrix into an igraph object is quite straightforward. The only difficulty is setting the parameters correctly (Is the network directed or not?), especially for edgelists where it may not immediately be obvious if the network is directed or not.\n\nIn the following, we use a larger network to introduce some terminology.\n\n\n::: {.cell hash='index_cache/html/load_greys_ae6011bb0e8a61f8c41ef3685c1a0d7a'}\n\n```{.r .cell-code}\ndata(\"greys\")\n```\n:::\n\n::: {.cell hash='index_cache/html/plot_greys_a543f65699ea5c317fe90e0b656bff96'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot_greys-1.png){width=100%}\n:::\n:::\n\n\nThe \"greys\" network is part of the `networkdata` package and consists of most characters from the \nshow \"Grey's Anatomy\" and who hooked up with whom.\n\n\n::: {.cell hash='index_cache/html/print_greys_703d58d4beae13df3c9c65ae3693d69e'}\n\n```{.r .cell-code}\ngreys\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH f7716f1 UN-- 54 57 -- \n+ attr: name (v/c), sex (v/c), race (v/c), birthyear (v/n), position\n| (v/c), season (v/n), sign (v/c)\n+ edges from f7716f1 (vertex names):\n [1] Arizona Robbins--Leah Murphy     Alex Karev     --Leah Murphy    \n [3] Arizona Robbins--Lauren Boswell  Arizona Robbins--Callie Torres  \n [5] Erica Hahn     --Callie Torres   Alex Karev     --Callie Torres  \n [7] Mark Sloan     --Callie Torres   George O'Malley--Callie Torres  \n [9] Izzie Stevens  --George O'Malley Meredith Grey  --George O'Malley\n[11] Denny Duqutte  --Izzie Stevens   Izzie Stevens  --Alex Karev     \n[13] Derek Sheperd  --Meredith Grey   Preston Burke  --Cristina Yang  \n+ ... omitted several edges\n```\n:::\n:::\n\n\n\n---\n\n# Descriptives and more notations\n\nThe **density** of a network is defined as the fraction of the potential edges in a network that are actually present.\n\n::: {.cell hash='index_cache/html/density_959732d302ec7c2b24d9f44167e942b3'}\n\n```{.r .cell-code}\nc(graph.density(graph.empty(10)),\n  graph.density(greys),\n  graph.density(graph.full(10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0000000 0.0398323 1.0000000\n```\n:::\n:::\n\n\nThe density of an empty network is $0$ and for the full network it is $1$. The density of empirical network \nlies somewhere in between but as the number of nodes increases, we'd expect the density to decrease and the network \nbecomes quite sparse.\n\nA **shortest path** is a path that connects two nodes in a network with a minimal number of edges. The length of a shortest path is called the **distance** between two nodes.\n\n::: {.cell hash='index_cache/html/shortest_path_d5795a5cb2a719cb68ec3533d93f03f5'}\n\n```{.r .cell-code}\nshortest_paths(greys,from = \"Alex Karev\",to = \"Owen Hunt\",output = \"vpath\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vpath\n$vpath[[1]]\n+ 5/54 vertices, named, from f7716f1:\n[1] Alex Karev         Addison Montgomery Mark Sloan         Teddy Altman      \n[5] Owen Hunt         \n\n\n$epath\nNULL\n\n$predecessors\nNULL\n\n$inbound_edges\nNULL\n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/greys_shortest_path_8b50e108b52c59a7d983a4d6febaf813'}\n::: {.cell-output-display}\n![](index_files/figure-html/greys_shortest_path-1.png){width=100%}\n:::\n:::\n\n::: {.cell hash='index_cache/html/distances_811c62f4901dbf72099aae8f30eeef69'}\n\n```{.r .cell-code}\ndistances(greys)[1:10,1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   Addison Montgomery Adele Webber Teddy Altman Amelia Shepherd\nAddison Montgomery                  0          Inf            2               2\nAdele Webber                      Inf            0          Inf             Inf\nTeddy Altman                        2          Inf            0               2\nAmelia Shepherd                     2          Inf            2               0\nArizona Robbins                     3          Inf            3               3\nRebecca Pope                        2          Inf            4               4\nJackson Avery                       3          Inf            3               3\nMiranda Bailey                    Inf          Inf          Inf             Inf\nBen Warren                        Inf          Inf          Inf             Inf\nHenry Burton                        3          Inf            1               3\n                   Arizona Robbins Rebecca Pope Jackson Avery Miranda Bailey\nAddison Montgomery               3            2             3            Inf\nAdele Webber                   Inf          Inf           Inf            Inf\nTeddy Altman                     3            4             3            Inf\nAmelia Shepherd                  3            4             3            Inf\nArizona Robbins                  0            3             4            Inf\nRebecca Pope                     3            0             3            Inf\nJackson Avery                    4            3             0            Inf\nMiranda Bailey                 Inf          Inf           Inf              0\nBen Warren                     Inf          Inf           Inf              1\nHenry Burton                     4            5             4            Inf\n                   Ben Warren Henry Burton\nAddison Montgomery        Inf            3\nAdele Webber              Inf          Inf\nTeddy Altman              Inf            1\nAmelia Shepherd           Inf            3\nArizona Robbins           Inf            4\nRebecca Pope              Inf            5\nJackson Avery             Inf            4\nMiranda Bailey              1          Inf\nBen Warren                  0          Inf\nHenry Burton              Inf            0\n```\n:::\n:::\n\n\nThe Grey's Anatomy network is **disconnected** and consists of $4$ **connected components**. There are no \nshortest paths between components, which means that the distance is not measurable and set to infinity.\n\nThe length of the longest shortest path is called the **diameter** of the network.\n\n::: {.cell hash='index_cache/html/diameter_c2b1bda232539573fa0748e497854f52'}\n\n```{.r .cell-code}\ndiameter(greys)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/greys_diameter_2381ac0ce2ea2a4deebeffb1f32b1f04'}\n::: {.cell-output-display}\n![](index_files/figure-html/greys_diameter-1.png){width=100%}\n:::\n:::\n\n\n\n**Transitivity** measures the probability that the neighbors of a node are also connected. This is also called the **clustering coefficient**.  \n\n::: {.cell hash='index_cache/html/transitivity_fea7b9a82814ecd10c6b541bb3d2d5a7'}\n\n```{.r .cell-code}\ntransitivity(greys, type = \"global\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ntransitivity(greys, type = \"local\", isolates = \"zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n```\n:::\n:::\n\nThe global transitivity of an undirected network is the ratio of the triangles and the connected triples in the network.\nLocal transitivity of a node is the ratio of the triangles connected to the node and the triples centered on the node itself.\nIn social networks, we generally assume that the transitivity is quite high (\"the friend of my friend is also my friend\"). In our \nexample, we have zero for all values. This is due to the fact that a triangle would require a same sex hook-up which did not occur (*Disclaimer: I never watched the show and gathered the hook ups from various internet resources. So this may well be wrong.*).\n\nFor directed networks, a measure of importance is **reciprocity**, which is defined as the proportion of mutual edges between nodes. To illustrate the measure, we use a network of grooming relations among a group of rhesus monkeys.\n\n\n::: {.cell hash='index_cache/html/reciprocity_example_e1b4bfa847c24ac220eff0e8f3b3e12a'}\n\n```{.r .cell-code}\ndata(\"rhesus\")\nreciprocity(rhesus)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.756757\n```\n:::\n:::\n\n\nAbout 76% of edges are reciprocated in the network. The figure below highlights the reciprocated edges. \n\n\n::: {.cell hash='index_cache/html/rhesus_net_740d6d8d24113ad4a734e187d664a6b8'}\n::: {.cell-output-display}\n![](index_files/figure-html/rhesus_net-1.png){width=100%}\n:::\n:::\n\n\n\n## Use case: triad census\n\n\n<details>\n\n<summary>Expand</summary>\n\nIn this short use case example, we will discuss the **triad census** of a directed network.\nIn a directed network, there are 16 possible configurations of edges that can occur between three nodes.\n\n![](triad_census.jpg)\n\nThe triad census of a network gives the number of occurrences of each of these triad. Triads are labelled `xyzL` where `x` is the number of reciprocated ties, `y` is the number of unreciprocated ties and `z` is the number of null ties. The `L` term is a letter (U,C,D or T) which allows to differentiate between triads where these numbers are the same. \n\nOne of the many applications of the triad census is to compare a set of networks.\nIn this example, we are tackling the question of \"how transitive is football?\" and\nasses structural differences among a set of football leagues. \n\n\n::: {.cell hash='index_cache/html/football_triad_c65ce92aee20708afe81e27b9f8b1ef7'}\n\n```{.r .cell-code}\ndata(\"football_triad\")\n```\n:::\n\n`football_triad` is a list which contains networks of 112 football leagues as igraph objects. A directed link between\nteam A and B indicates that A won a match against B. Note that there can also be an edge from B to A,\nsince most leagues play a double round robin. For the sake of simplicity, all draws were deleted so that\nthere could also be null ties between two teams if both games ended in a draw.\n\nBelow, we calculate the triad census for all network at once using `lapply()`.\nThe function returns the triad census for each network as a list, which we turn into a matrix\nin the second step. Afterwards, we manually add the row and column names of the matrix.\n\n\n::: {.cell hash='index_cache/html/football_census_e58899fcbde4944925b4cb9f0e6cf17d'}\n\n```{.r .cell-code}\nfooty_census <- lapply(football_triad,triad_census) \nfooty_census <- matrix(unlist(footy_census),ncol=16,byrow = T)\nrownames(footy_census) <- sapply(football_triad,function(x) x$name)\ncolnames(footy_census) <- c(\"003\",\"012\",\"102\",\"021D\",\"021U\",\"021C\",\"111D\",\"111U\",\n                         \"030T\",\"030C\",\"201\",\"120D\",\"120U\",\"120C\",\"210\",\"300\")\n\n#normalize to make proportions comparable across leagues\nfooty_census_norm <- footy_census/rowSums(footy_census)\n\n#check the Top 5 leagues\nidx <- which(rownames(footy_census)%in%c(\"england\",\"spain\",\"germany\",\n                                      \"italy\",\"france\"))\nfooty_census[idx,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        003 012 102 021D 021U 021C 111D 111U 030T 030C 201 120D 120U 120C 210\nengland   2  10   0   58   31   40   34   44  338   29  19  118  129  143 131\nfrance    1  23   5   30   33   44   48   40  332   41  16  132  108  160 114\ngermany   0  21   6   27   19   49   38   46  165   16  23   77   79  117 120\nitaly     1   4   2   35   43   30   30   22  419   38   5  164  116  118  99\nspain     0   8   4   27   42   45   32   35  364   43  11  126  105  148 130\n        300\nengland  14\nfrance   13\ngermany  13\nitaly    14\nspain    20\n```\n:::\n:::\n\n\nNotice how the transitive triad (030T) has the largest count in the top leagues, hinting toward the childhood wisdom:\n\"If A wins against B and B wins against C, then A must win against C\".\n\nIn empirical studies, we are not necessarily only interested in transitive triads, but rather how the triad census profiles compare across networks. We follow [Kathrine Faust's](https://doi.org/10.1111%2Fj.1467-9531.2007.00179.x) suggestion and do a singular value decomposition (SVD) on the normalized triad census matrix.\n\n\n::: {.cell hash='index_cache/html/svd_footy_1b33a0e5e2b6a87dc76fd6f2b3957b3b'}\n\n```{.r .cell-code}\nfooty_svd <- svd(footy_census_norm)\n```\n:::\n\n\nSVDs are used to reduce the dimensionality of the data, but retaining most of the information. In our case, the \ndata is 16 dimensional, which is impossible to visualize to compare the networks. With an SVD, we can reduce it to two dimensions and get a better visual overview.\n\n\n::: {.cell hash='index_cache/html/plot_svd_u_ea901587eb81b37f89cecf6763bb375e'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot_svd_u-1.png){width=100%}\n:::\n:::\n\n\nHow to interpret the dimensions? To investigate this question, we take a closer look at the first two dimensions and compare it to some network descriptives. For the sake of brevity, we here only look at the density and proportion of 030T triads. In\ngeneral, any node/dyad/triad level statistic could be used.\n\n\n::: {.cell hash='index_cache/html/svd1_density_8bf42f43152d819aa77177c38eacb46b'}\n::: {.cell-output-display}\n![](index_files/figure-html/svd1_density-1.png){width=100%}\n:::\n:::\n\n\nDensity doesn't really seem to be related to the first dimension in this case (in many cases it is!). Might be worthwhile to\nexplore this further\n\n\n::: {.cell hash='index_cache/html/svd2_030T_e8c64a940183bfc402420964c3d5fed2'}\n::: {.cell-output-display}\n![](index_files/figure-html/svd2_030T-1.png){width=100%}\n:::\n:::\n\n\nFor the second dimension, we get a clearer association. It seems that the fraction of transitive triads \nis a good indicator for structural differences among leagues.\n\nMore details can be found in the paper by Kathrine Faust.\n\n</details>\n\n---\n\n# Centrality\n\nIn a nutshell, a measure of centrality is an index that assigns a numeric values to\nthe nodes of the network. The higher the value, the more central the node. \"Being central\" \nis a very ambiguous term and it is thus no surprise that there exists a large variety of \nindices that assess centrality with very different structural properties of the network.\n\nGiven the abundance of measures, we will also look at dedicated centrality packages that implement indices\nwhich are not available in `igraph`.\n\n`igraph` contains the following 10 indices:\n\n- degree (`degree()`)\n- weighted degree (`graph.strength()`)\n- betweenness (`betweenness()`)\n- closeness (`closeness()`)\n- eigenvector (`eigen_centrality()`)\n- alpha centrality (`alpha_centrality()`)\n- power centrality (`power_centrality()`)\n- PageRank (`page_rank()`)\n- eccentricity (`eccentricity()`)\n- hubs and authorities (`authority_score()` and `hub_score()`)\n- subgraph centrality (`subgraph_centrality()`)\n\nTo illustrate some of the indices, we use the \"dbces11\" graph which is part of the `netrankr` package.\n\n::: {.cell hash='index_cache/html/load_dbces_417bc5ccdb85db806e2afb307d8fcc99'}\n\n```{.r .cell-code}\ndata(\"dbces11\")\n```\n:::\n\n::: {.cell hash='index_cache/html/dbces11_basic_plot_55ecdfa0d8840040ae00e15409a04c16'}\n::: {.cell-output-display}\n![](index_files/figure-html/dbces11_basic_plot-1.png){width=100%}\n:::\n:::\n\n\n**degree** simply counts the number of neighbors a node has.\n\n::: {.cell hash='index_cache/html/degree_dbces11_3efd2db08c9f19194013548ef399a767'}\n\n```{.r .cell-code}\ndegree(dbces11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA B C D E F G H I J K \n1 1 2 2 3 4 4 4 4 4 5 \n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/degree_dbces11_plot_4903a49bccd607554dd1218dea8ac378'}\n::: {.cell-output-display}\n![](index_files/figure-html/degree_dbces11_plot-1.png){width=100%}\n:::\n:::\n\n\n\n**closeness** computes the shortest path distances among nodes. The most central node has the\nminimum distance to all other nodes (Since high scores are associated with central nodes, the distances are inverted).\n\n::: {.cell hash='index_cache/html/closeness_dbces11_72dbe1687be64beffe727449f45d5815'}\n\n```{.r .cell-code}\ncloseness(dbces11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        A         B         C         D         E         F         G         H \n0.0370370 0.0294118 0.0400000 0.0400000 0.0500000 0.0588235 0.0526316 0.0555556 \n        I         J         K \n0.0555556 0.0526316 0.0555556 \n```\n:::\n:::\n\nThe animation below gives an intuition on the calculation for one node.\n![](closeness.gif)\n\n**betweeness** is the number of shortest paths that pass through a node (divided by the total number of shortest paths)  \n\n::: {.cell hash='index_cache/html/betweenness_dbces11_eb17ae40d8d2d6529596e3a28e7fd00e'}\n\n```{.r .cell-code}\nbetweenness(dbces11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       A        B        C        D        E        F        G        H \n 0.00000  0.00000  0.00000  9.00000  3.83333  9.83333  2.66667 16.33333 \n       I        J        K \n 7.33333  1.33333 14.66667 \n```\n:::\n:::\n\n\nTo get an intuition what it means to have a high betweenness, check the network below.\n\n::: {.cell hash='index_cache/html/betweenness_bridge_7aa3d8213cd8bcdcf13bd564239f028c'}\n::: {.cell-output-display}\n![](index_files/figure-html/betweenness_bridge-1.png){width=100%}\n:::\n:::\n\n\nAny shortest path from the right will pass through the red node and vice versa. The \nred note is thus a sort of \"gatekeeper\" for any information that is passed from left to right.\n\n\n**eigenvector centrality** extends the idea of degree by assuming that a node is central if it is connected to other central nodes.\n\n::: {.cell hash='index_cache/html/eigen_dbces11_e455432cd5712a7cf82d992faa854448'}\n\n```{.r .cell-code}\neigen_centrality(dbces11)$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        A         B         C         D         E         F         G         H \n0.2259630 0.0645825 0.3786244 0.2415182 0.5709057 0.9846544 1.0000000 0.8386195 \n        I         J         K \n0.9113529 0.9986474 0.8450304 \n```\n:::\n:::\n\n\n**subgraph centrality** is a bit more abstract but what it does is summing up all closed walks weighting them by the \ninverse factorial of its length.\n\n\n::: {.cell hash='index_cache/html/sub_dbces11_6218fb856cf849232f284318185b8c63'}\n\n```{.r .cell-code}\nsubgraph_centrality(dbces11)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      A       B       C       D       E       F       G       H       I       J \n1.82510 1.59540 3.14857 2.42309 4.38713 7.80726 7.93941 6.67278 7.03267 8.24212 \n      K \n7.38956 \n```\n:::\n:::\n\n\nThe remaining indices are mostly designed for directed networks, **page rank** being the prime example. Note, though that\nthe mentioned indices can also be applied to directed networks. \n\nIf we highlight the most central node for the calculated indices, we get the following. \n\n::: {.cell hash='index_cache/html/dbces11_plot_dbb3057381ad34ff46f7bde2f3ebb6c8'}\n::: {.cell-output-display}\n![](index_files/figure-html/dbces11_plot-1.png){width=100%}\n:::\n:::\n\n\nSo each index picks a different node as most central. While this is just a toy example, it highlights\nhow influential the choice of indices can be in empirical settings.\n\n10 is already quite a lot of indices, but there exist far more in the literature. Some of those are\nimplemented in other packages.\n\nThe `sna` package implements roughly the same indices as `igraph` but adds:\n\n- flow betweenness (`flowbet()`)\n- load centrality (`loadcent()`)\n- Gil-Schmidt Power Index (`gilschmidt()`)\n- information centrality (`infocent()`)\n- stress centrality (`stresscent()`)\n\nThere are also some dedicated centrality packages, such as `centiserve`, `CINNA`, `influenceR` and `keyplayer`.\nThe biggest in terms of implemented indices is currently `centiserve` with a total of 33 indices.\n\n::: {.cell hash='index_cache/html/centiserve_7b2186edb093ea525419aaea1b88a05d'}\n\n```{.r .cell-code}\nlibrary(centiserve)\nas.character(lsf.str(\"package:centiserve\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"averagedis\"            \"barycenter\"            \"bottleneck\"           \n [4] \"centroid\"              \"closeness.currentflow\" \"closeness.freeman\"    \n [7] \"closeness.latora\"      \"closeness.residual\"    \"closeness.vitality\"   \n[10] \"clusterrank\"           \"communibet\"            \"communitycent\"        \n[13] \"crossclique\"           \"decay\"                 \"diffusion.degree\"     \n[16] \"dmnc\"                  \"entropy\"               \"epc\"                  \n[19] \"geokpath\"              \"hubbell\"               \"katzcent\"             \n[22] \"laplacian\"             \"leaderrank\"            \"leverage\"             \n[25] \"lincent\"               \"lobby\"                 \"markovcent\"           \n[28] \"mnc\"                   \"pairwisedis\"           \"radiality\"            \n[31] \"salsa\"                 \"semilocal\"             \"topocoefficient\"      \n```\n:::\n:::\n\nThe package is maintained by the team behind [centiserver](http://www.centiserver.org/),\nthe \"comprehensive centrality resource and server for centralities calculation\".\nThe website collects indices found in the literature. Currently (February 2022), it lists 403 different indices.\nThat's...a lot.\n\nThe description of `CINNA` says\n\"Functions for computing, comparing and demonstrating top informative centrality measures within a network.\"\nMost of the indices in the package are imported from other package, such as `centiserve`.\nIn addition, there are:\n\n- Dangalchev closeness (`dangalchev_closeness_centrality()`)\n- group centrality (`group_centrality()`)\n- harmonic closeness (`harmonic_centrality()`)\n- local bridging centrality (`local_bridging_centrality()`)\n\nThe function `calculate_centralities()` can be used to calculate all applicable indices\nto a network. The primary purpose of the package is to facilitate the choice of indices\nby visual and statistical tools. If you are interested in the details, see this [tutorial](https://www.datacamp.com/community/tutorials/centrality-network-analysis-R)\nand this [vignette](https://cran.r-project.org/web/packages/CINNA/vignettes/CINNA.html).\n\n`influenceR` and `keyplayer` are comparably small packages which implement only a small\nnumber of indices.\n\nThe choice of indices can be overwhelming and little guidelines exist on when to choose what.\nThe worst thing to do in any case is to apply a handful of indices and pick the result that suits your\ninterpretation best. In best case, you have substantive arguments to apply an index and the result \ndoes match the hypothesis (or not).\n\n## Use case: Florentine Families\n\n<details>\n\n<summary>Expand</summary>\n\n\nA classic example application of centrality indices is the \"Florentine Families\" dataset, which is included in the `networkdata` package.\n\n::: {.cell hash='index_cache/html/flo_data_3825bdef1ff858abae28d0a12c567caf'}\n\n```{.r .cell-code}\ndata(\"flo_marriage\")\n```\n:::\n\n::: {.cell hash='index_cache/html/flo_plot_fc5a94ee1d45f405dba405717ded0e32'}\n::: {.cell-output-display}\n![](index_files/figure-html/flo_plot-1.png){width=100%}\n:::\n:::\n\n\nTh network shows marriage ties among Renaissance Families in Florence. Marriages at that time were\nstrategic to improve the standing of families in society. The size of the names is proportional to the \nwealth of the families. Although the Strozzi were the wealthiest family, it was ultimately the Medici\nwho became the most powerful family. This is in part due to their central position within this marriage network.\n\nThe table bellow shows the ranking for the four most commonly used centrality indices (1=top rank).\n\n::: {.cell hash='index_cache/html/centralities_flo_52d19c64ef5d238636689ccf70469837'}\n::: {.cell-output-display}\n|name         | degree| betweenness| closeness| eigen|\n|:------------|------:|-----------:|---------:|-----:|\n|Acciaiuoli   |   13.5|          14|      11.5|    12|\n|Albizzi      |    6.5|           3|       3.5|     9|\n|Barbadori    |   10.5|           8|       6.5|    10|\n|Bischeri     |    6.5|           6|       8.0|     6|\n|Castellani   |    6.5|          10|       9.5|     8|\n|Ginori       |   13.5|          14|      13.0|    14|\n|Guadagni     |    2.5|           2|       5.0|     5|\n|Lamberteschi |   13.5|          14|      14.0|    13|\n|Medici       |    1.0|           1|       1.0|     1|\n|Pazzi        |   13.5|          14|      15.0|    15|\n|Peruzzi      |    6.5|          11|      11.5|     7|\n|Pucci        |   16.0|          14|      16.0|    16|\n|Ridolfi      |    6.5|           5|       2.0|     3|\n|Salviati     |   10.5|           4|       9.5|    11|\n|Strozzi      |    2.5|           7|       6.5|     2|\n|Tornabuoni   |    6.5|           9|       3.5|     4|\n:::\n:::\n\n\nNo matter what structural feature we consider to be important, the Medici always have the most advantageous position.\n\n</details>\n\n## Additional Material\n\nI have written a series of blog post about the concept of network centrality, which introduces\nsome novel tools to assess centrality. These also discuss empirical applications of indices in greater detail. ([1](http://blog.schochastics.net/post/network-centrality-in-r-introduction/),\n [2](http://blog.schochastics.net/post/network-centrality-in-r-neighborhood-inclusion/),\n [3](http://blog.schochastics.net/post/network-centrality-in-r-new-ways-of-measuring-centrality/))\n\nThe blog posts rely on the `netrankr` package ([link](http://netrankr.schochastics.net/)), which also \ncomes with 9 vignettes that explain the functionality in great detail. Note that the package also\nimplements around 30 indices, but the index based approach is not its main purpose.\n\n\n---\n\n# Cliques and Clustering\n\nA *clique* in a network is a set of nodes that form a complete subnetwork within a network (called a complete **subgraph**). A **maximal clique** is a clique that cannot be extended to a bigger clique by addding more nodes to it. \n\n\n::: {.cell hash='index_cache/html/load_clique_graph_260ce9fa7a8574e638a3636825e5ab2f'}\n\n```{.r .cell-code}\ndata(\"clique_graph\")\n```\n:::\n\n\nAll maximal cliques can be calculated with `max_cliques()` (only feasible for fairly small networks). The min parameter can be used to set a minimum size. Here, we want to ignore all cliques of size $2$.\n\n::: {.cell hash='index_cache/html/calc_max_cliques_0f0904dbb5235f9ce1be78def2d3fd99'}\n\n```{.r .cell-code}\n# only return cliques with three or more nodes\ncl <- max_cliques(clique_graph,min = 3)\ncl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 3/30 vertices, from 0193e05:\n[1]  9 17 18\n\n[[2]]\n+ 3/30 vertices, from 0193e05:\n[1] 7 4 5\n\n[[3]]\n+ 3/30 vertices, from 0193e05:\n[1] 7 4 8\n\n[[4]]\n+ 3/30 vertices, from 0193e05:\n[1] 10  2 11\n\n[[5]]\n+ 3/30 vertices, from 0193e05:\n[1] 16 12 15\n\n[[6]]\n+ 3/30 vertices, from 0193e05:\n[1] 6 1 5\n\n[[7]]\n+ 4/30 vertices, from 0193e05:\n[1] 12 13 15 14\n\n[[8]]\n+ 3/30 vertices, from 0193e05:\n[1] 12  2  1\n\n[[9]]\n+ 5/30 vertices, from 0193e05:\n[1] 1 2 5 4 3\n```\n:::\n:::\n\n\nThe figure below shows the network and the found maximal cliques.\n\n\n::: {.cell hash='index_cache/html/plot_clique_graph_e2d8e9fef3bd4ac0c9ae94e25356dd95'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot_clique_graph-1.png){width=100%}\n:::\n:::\n\n\nRelated to cliques is the **k-core decomposition** of a network. A k-core is a subgraph in which every node has at least k neighbors within the subgraph. A k-core is thus a relaxed version of a clique.  \nThe function `coreness()` can be used to calculate the k-core membership for each node.\n\n::: {.cell hash='index_cache/html/kcore_0608965cdb4837419398605692eabda9'}\n\n```{.r .cell-code}\nkcore <- coreness(clique_graph)\nkcore\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 4 4 4 4 4 3 2 2 2 2 2 3 3 3 3 3 2 2 1 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/kcore_plot_ef0ea278362c833bfa095aad8568a7b6'}\n::: {.cell-output-display}\n![](index_files/figure-html/kcore_plot-1.png){width=100%}\n:::\n:::\n\n\nCliques are the prototypical and most strict definition of a cohesive subgroup of a graph. In empirical networks, however, we rarely encounter situations where we can partition the whole network into a set of \ncliques. A relaxed version of this problem is that of clustering, also referred to as **comunity detection**. \nA cluster is loosely defined as a group of nodes which are internally densely and externally sparsely connected. The network below shows an example for a network with a visible and intuitive cluster structure.\n\n\n::: {.cell hash='index_cache/html/clustered_graph_58046d190a40e3811e4bc9fea4c141ad'}\n::: {.cell-output-display}\n![](index_files/figure-html/clustered_graph-1.png){width=100%}\n:::\n:::\n\n\nIn contrast, the network below does not really seem to have any well defined cluster structure.\n\n\n::: {.cell hash='index_cache/html/random_graph_cafcf3c5ea81b37fc67167d44ffaec98'}\n::: {.cell-output-display}\n![](index_files/figure-html/random_graph-1.png){width=100%}\n:::\n:::\n\n\nThe following algorithms for graph clustering are implemented in `igraph`.\n\n\n::: {.cell hash='index_cache/html/cluster_alg_15285762a217d8b0efeecf0eed45f64a'}\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"cluster_edge_betweenness\"  \"cluster_fast_greedy\"      \n [3] \"cluster_fluid_communities\" \"cluster_infomap\"          \n [5] \"cluster_label_prop\"        \"cluster_leading_eigen\"    \n [7] \"cluster_leiden\"            \"cluster_louvain\"          \n [9] \"cluster_optimal\"           \"cluster_spinglass\"        \n[11] \"cluster_walktrap\"         \n```\n:::\n:::\n\n\nMost of these algorithms are based on \"modularity maximization\". Modularity is defined as the fraction of edges that fall within given groups minus the expected fraction if edges were distributed at random.\n\nThe workflow of a cluster analysis is always the same, independent from the chosen method. We illustrate the workflow using the infamous karate club network.\n\n::: {.cell hash='index_cache/html/karate_d94fa47d4477369488aa2f921075745c'}\n\n```{.r .cell-code}\ndata(\"karate\")\n```\n:::\n\n::: {.cell hash='index_cache/html/karate_plot_f73e1e92cc649cc64019bfec1b9ae096'}\n::: {.cell-output-display}\n![](index_files/figure-html/karate_plot-1.png){width=100%}\n:::\n:::\n\n::: {.cell hash='index_cache/html/cluster_ex_b5cf861324bb33da2b62229367d72542'}\n\n```{.r .cell-code}\n# compute clustering\nclu <- cluster_louvain(karate)\n\n# cluster membership vector\nmem <- membership(clu)\nmem\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 2 2 2 1 3 1 2 1 1 1 3 3 2 1 3 1 3 1 3 4 4 4 3 4 4 3 3 4 3 3\n```\n:::\n\n```{.r .cell-code}\n# clusters as list\ncom <- communities(clu)\ncom\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n [1]  1  2  3  4  8 10 12 13 14 18 20 22\n\n$`2`\n[1]  5  6  7 11 17\n\n$`3`\n [1]  9 15 16 19 21 23 27 30 31 33 34\n\n$`4`\n[1] 24 25 26 28 29 32\n```\n:::\n:::\n\n\nTo compare the quality of clusterings, we can compute the modularity score for each output.\n\n\n::: {.cell hash='index_cache/html/karate_cluster_a16c7fc36fe629df6d9eca68a07eadc2'}\n\n```{.r .cell-code}\nimc <- cluster_infomap(karate)\nlec <- cluster_leading_eigen(karate)\nloc <- cluster_louvain(karate)\nsgc <- cluster_spinglass(karate)\nwtc <- cluster_walktrap(karate)\nscores <- c(infomap = modularity(karate,membership(imc)),\n            eigen = modularity(karate,membership(lec)),\n            louvain = modularity(karate,membership(loc)),\n            spinglass = modularity(karate,membership(sgc)),\n            walk = modularity(karate,membership(wtc)))\nscores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  infomap     eigen   louvain spinglass      walk \n 0.402038  0.393409  0.419790  0.419790  0.353222 \n```\n:::\n:::\n\n\nFor the karate network, `cluster_spinglass()` produces the highest modularity score.\nThe corresponding clustering is shown below.\n\n\n::: {.cell hash='index_cache/html/karate_plot_clu_114a6c32aaa696394a924cd7d0c667e4'}\n::: {.cell-output-display}\n![](index_files/figure-html/karate_plot_clu-1.png){width=100%}\n:::\n:::\n\n\nModularity maximization is still widely considered as the state-of-the-art clustering method\nfor networks. There are, however, some technical shortcomings that one should be aware of.\nOne of those is the so called \"resolution limit\". When modularity is being maximized, it can happen\nthat smaller clusters are merged together to form bigger clusters. The prime example is the graph that\nconsists of cliques connected in a ring.\n\n\n::: {.cell hash='index_cache/html/prepare_Kn_graph_a634437083b0f932a5f5e61d8c346b27'}\n\n:::\n\n\nThe figure below shows such a graph, consisting of 50 cliques of size 5. \n\n\n::: {.cell hash='index_cache/html/plot_K50_blank_64a7e3c18f210db6c07231e9546e6918'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot_K50_blank-1.png){width=100%}\n:::\n:::\n\n\nIntuitively, any clustering method should return a cluster for each clique.\n\n\n::: {.cell hash='index_cache/html/clu_louvain_K50_96d6db681c18624714d57c625e3497cb'}\n\n```{.r .cell-code}\nclu_louvain <- cluster_louvain(K50)\ntable(membership(clu_louvain))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \n15 10 10 10 10 10 15 10 10 10 10 10 15 10 10 10 10 10 10 15 10 10 10 \n```\n:::\n:::\n\n\nA clustering algorithm that fixes this issue is the leiden algorithm.\n\n\n::: {.cell hash='index_cache/html/clu_leiden_K50_f33389d0898cc71f4b23dd5837d2c454'}\n\n```{.r .cell-code}\nclu_leiden <- cluster_leiden(K50,objective_function = \"CPM\",resolution_parameter = 0.5)\ntable(membership(clu_leiden))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \n 5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5 \n27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \n 5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5 \n```\n:::\n:::\n\n\nThe figure below shows the clusters computed with the louvain method in grey and the leiden method in red.\n\n\n::: {.cell hash='index_cache/html/plot_K50_clu_e1afda9915ef2e88abeb3e740c43c547'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot_K50_clu-1.png){width=100%}\n:::\n:::\n\n\nI'll spare the technical details of the leiden method. If you are interested, check out the [original paper](https://www.nature.com/articles/s41598-019-41695-z). \n\n---\n\n# Blockmodeling\n\nBlockmodeling is similar to \n\n(Stochastic) Blockmodels, for instance,\ncan also be used to find community structures. Several packages exist for this, such as `randnet` or `blockmodels`.\n\n---\n\n# Core-Periphery structures\n\n---\n\n# I want to learn about ...\n\n## ... two mode networks\n\n<details>\n\n<summary>Expand</summary>\n\nA two mode network is a network that consists of two disjoint sets of nodes (like people and events). \nTies connect the two sets, e. g. participation of people in events. There exists a great variety\nof two mode networks. The most often encountered ones are \n\n- Affiliation networks (Membership in institutions)\n- Voting/Sponsorship networks (politicians and bills)\n- Citation network (authors and papers)\n- Co-Authorship networks (authors and papers)\n\nBelow we will discuss some methods via the famous \"southern women\" dataset consisting of\n18 women who attended a series of 14 events.\n\n::: {.cell hash='index_cache/html/southern_dat_load_4aa908e69df8cbe6223a6c4ca8820358'}\n\n```{.r .cell-code}\ndata(\"southern_women\")\n```\n:::\n\n::: {.cell hash='index_cache/html/southern_women_8c92fcf01fd466028bf820f9d3db6810'}\n::: {.cell-output-display}\n![](index_files/figure-html/southern_women-1.png){width=100%}\n:::\n:::\n\n\nThe adjacency matrix of a two mode network is also referred to as an incidence matrix and can be obtained via\n`as_incidence_matrix()`\n\n\n::: {.cell hash='index_cache/html/incidence_southern_d3f8cf0e303a95139390b1f138f202cc'}\n\n```{.r .cell-code}\nA <- as_incidence_matrix(southern_women)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\nEVELYN       1   1    1    1    1    1    0    1   1    0    0   0     0   0\nLAURA        1   1    1    0    1    1    1    1   0    0    0   0     0   0\nTHERESA      0   1    1    1    1    1    1    1   1    0    0   0     0   0\nBRENDA       1   0    1    1    1    1    1    1   0    0    0   0     0   0\nCHARLOTTE    0   0    1    1    1    0    1    0   0    0    0   0     0   0\nFRANCES      0   0    1    0    1    1    0    1   0    0    0   0     0   0\nELEANOR      0   0    0    0    1    1    1    1   0    0    0   0     0   0\nPEARL        0   0    0    0    0    1    0    1   1    0    0   0     0   0\nRUTH         0   0    0    0    1    0    1    1   1    0    0   0     0   0\nVERNE        0   0    0    0    0    0    1    1   1    0    0   1     0   0\nMYRNA        0   0    0    0    0    0    0    1   1    1    0   1     0   0\nKATHERINE    0   0    0    0    0    0    0    1   1    1    0   1     1   1\nSYLVIA       0   0    0    0    0    0    1    1   1    1    0   1     1   1\nNORA         0   0    0    0    0    1    1    0   1    1    1   1     1   1\nHELEN        0   0    0    0    0    0    1    1   0    1    1   1     0   0\nDOROTHY      0   0    0    0    0    0    0    1   1    0    0   0     0   0\nOLIVIA       0   0    0    0    0    0    0    0   1    0    1   0     0   0\nFLORA        0   0    0    0    0    0    0    0   1    0    1   0     0   0\n```\n:::\n:::\n\n\nThe `tnet` ([link](https://CRAN.R-project.org/package=tnet)) and `bipartite` ([link](https://CRAN.R-project.org/package=bipartite)) offer some methods to analyse two mode networks directly, by \nadapting tools for standard (one-mode) networks (like the ones described above).\n\nBesides analyzing a two-mode network as-is, there is also the possibility to project it to one mode. \nMathematically, this is done by calculating $AA^T$ or $A^TA$, depending which mode we project on.\nAs an example, consider the southern women dataset again.\n\n::: {.cell hash='index_cache/html/proj_women_a531675945e344d9dae5c56b084740cc'}\n\n```{.r .cell-code}\nB <- A%*%t(A)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH\nEVELYN         8     6       7      6         3       4       3     3    3\nLAURA          6     7       6      6         3       4       4     2    3\nTHERESA        7     6       8      6         4       4       4     3    4\nBRENDA         6     6       6      7         4       4       4     2    3\nCHARLOTTE      3     3       4      4         4       2       2     0    2\nFRANCES        4     4       4      4         2       4       3     2    2\nELEANOR        3     4       4      4         2       3       4     2    3\nPEARL          3     2       3      2         0       2       2     3    2\nRUTH           3     3       4      3         2       2       3     2    4\nVERNE          2     2       3      2         1       1       2     2    3\nMYRNA          2     1       2      1         0       1       1     2    2\nKATHERINE      2     1       2      1         0       1       1     2    2\nSYLVIA         2     2       3      2         1       1       2     2    3\nNORA           2     2       3      2         1       1       2     2    2\nHELEN          1     2       2      2         1       1       2     1    2\nDOROTHY        2     1       2      1         0       1       1     2    2\nOLIVIA         1     0       1      0         0       0       0     1    1\nFLORA          1     0       1      0         0       0       0     1    1\n          VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA\nEVELYN        2     2         2      2    2     1       2      1     1\nLAURA         2     1         1      2    2     2       1      0     0\nTHERESA       3     2         2      3    3     2       2      1     1\nBRENDA        2     1         1      2    2     2       1      0     0\nCHARLOTTE     1     0         0      1    1     1       0      0     0\nFRANCES       1     1         1      1    1     1       1      0     0\nELEANOR       2     1         1      2    2     2       1      0     0\nPEARL         2     2         2      2    2     1       2      1     1\nRUTH          3     2         2      3    2     2       2      1     1\nVERNE         4     3         3      4    3     3       2      1     1\nMYRNA         3     4         4      4    3     3       2      1     1\nKATHERINE     3     4         6      6    5     3       2      1     1\nSYLVIA        4     4         6      7    6     4       2      1     1\nNORA          3     3         5      6    8     4       1      2     2\nHELEN         3     3         3      4    4     5       1      1     1\nDOROTHY       2     2         2      2    1     1       2      1     1\nOLIVIA        1     1         1      1    2     1       1      2     2\nFLORA         1     1         1      1    2     1       1      2     2\n```\n:::\n:::\n\n\nThis matrix can now be interpreted as a weighted network among the 18 women. Each entry corresponds to the number of times\ntwo women went to the same event.\n\n\n::: {.cell hash='index_cache/html/plot_weighted_proj_12aefbe399505a4241655fd0b5fbaf9a'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot_weighted_proj-1.png){width=100%}\n:::\n:::\n\n\nAs you can see, the network has become very dense. A very common step is now to binarize the\nnetwork. In doing so, we basically turn the network into a simple undirected one-mode network. This\nmakes all methods we described in the first few sections applicable to the network (at least in theory).\nThe simplest way of binarizing a weighted projection is to define a global threshold and remove a tie if\nits weight is below the global threshold. This is simple but come with many undesirable structural problems.\nMore sophisticated tools work with statistical models in the background which determine if an edge weight\ndiffers enough from the expected value. If so, the edge is kept in the binary \"backbone\" of the network. \n\nAll possible backbone extraction methods are implemented in the `backbone` package ([link](https://CRAN.R-project.org/package=backbone)). An introduction to the package can be\nfound on [arxiv](https://arxiv.org/abs/1912.12779).\n\n</details>\n\n## ... signed networks\n\n<details>\n\n<summary>Expand</summary>\n\nTraditional SNA usually deals with relations among entities (e.g. people) that are positive, including friendship, advice seeking, etc. Most network analytic tools are devised under this premise, be that centrality indices, clustering tools and so forth. But of course not all occurring relations are positive. People can be friends but also foes.\n\nThis gives rise to signed networks. These networks are usually composed of both, positive and negative, ties measured among a set of entities. Traditional network analytic tools are not applicable to such networks without adapting for the presents of negative ties. The `signnet` package ([link](https://CRAN.R-project.org/package=signnet)) brings together methods that have been developed to analyse signed networks. This includes\n\n- Structural balance ([tutorial](http://signnet.schochastics.net/articles/structural_balance.html))\n- Blockmodeling ([tutorial](http://signnet.schochastics.net/articles/blockmodeling.html))\n- Centrality ([tutorial](http://signnet.schochastics.net/articles/centrality.html))\n- Signed two-mode networks ([tutorial](http://signnet.schochastics.net/articles/signed_2mode.html))\n\nA dedicated tutorial for each methodology is given in the package vignettes, also linked above. Below, we\njust briefly discuss the structure of the package.\n\nThe foundation of `signnet` is provided by `igraph`. All functions in the package \nassume that an igraph object is a signed network if it has an edge attribute sign with values 1 (positive) or -1 (negative).\n\n::: {.cell hash='index_cache/html/signed_example_4957922e915e31de1fa1a5e4d8c35bf1'}\n\n```{.r .cell-code}\nlibrary(signnet)\ng <- graph.full(5,directed = FALSE,loops = FALSE)\nE(g)$sign <- 1\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH d5a26e9 U--- 5 10 -- Full graph\n+ attr: name (g/c), loops (g/l), sign (e/n)\n+ edges from d5a26e9:\n [1] 1--2 1--3 1--4 1--5 2--3 2--4 2--5 3--4 3--5 4--5\n```\n:::\n:::\n\n\nAll methods should throw an error if the sign attribute is missing or contains other values than -1 and 1.\n\nMatrices associated with a signed network follow the `igraph` naming scheme. The signed adjacency matrix can be obtained with `as_adj_signed()`.\n\n\n::: {.cell hash='index_cache/html/signed_adj_c4c5986f9885dc1afbe1d81df5b731a1'}\n\n```{.r .cell-code}\ndata(\"tribes\")\nas_adj_signed(tribes)[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Gavev Kotun Ove Alika Nagam\nGavev     0     1  -1    -1    -1\nKotun     1     0  -1     0    -1\nOve      -1    -1   0     1     0\nAlika    -1     0   1     0     0\nNagam    -1    -1   0     0     0\n```\n:::\n:::\n\n\nThe signed Laplacian matrix is obtained by `laplacian_matrix_signed()`.\n\n::: {.cell hash='index_cache/html/signed_lapl_36ac44178ac26646ebf6c821ecc3735e'}\n\n```{.r .cell-code}\nlaplacian_matrix_signed(tribes)[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Gavev Kotun Ove Alika Nagam\nGavev     8    -1   1     1     1\nKotun    -1     8   1     0     1\nOve       1     1   6    -1     0\nAlika     1     0  -1     3     0\nNagam     1     1   0     0     7\n```\n:::\n:::\n\n\nA function not explicitly mentioned in the tutorials linked above is `triad_census_signed()` which calculates the\nsigned triad census of a directed signed network. While the unsigned triad census has only 16 possible outcomes, there are 138 non-isomorphic signed triads, shown below.\n![](signed_triads.png)\nThe naming scheme is \"xxx-yyyyyy\" where \"xxx\" corresponds to the name of the respective unsigned triad and \"yyyyyy\" is \na string of \"0\", \"N\", \"P\", describing the type of ties present. So \"300-NNNNNN\" is a triad with all ties present and all ties are negative. \n\nThe package includes two well known datasets to play with.\n\nThe tribes dataset is a signed social network of tribes of the GahukuGama alliance structure of the Eastern Central Highlands of New Guinea. The network contains sixteen tribes connected by friendship (rova) and enmity (hina).\n\nThe cowList dataset contains a list of 52 signed networks of inter-state relations over time (1946-1999). Two countries are connected by a positive tie if they form an alliance or have a peace treaty. A negative tie exists between countries who are at war or in other kinds of conflicts. The dataset is derrived from the [correlates of war](https://correlatesofwar.org/).\n\n</details>\n\n## ... ego networks\n\n<details>\n\n<summary>Expand</summary>\n\nIf you want to analyze ego networks, then I can only recommend this\n[book](http://www.raffaelevacca.com/egocentric-r-book/) by [Raffaele Vacca](http://www.raffaelevacca.com/).\nRaffaele has given countless workshops on ego network analysis in R and his material should provide\nyou with everything you need.\n\n</details>\n\n## ... multilevel networks\n\n<details>\n\n<summary>Expand</summary>\n\nFor analyzing multilevel networks, I recommend the `multinet` pakage ([link](https://CRAN.R-project.org/package=multinets)).\nCheck out this [JSS Paper](http://multilayer.it.uu.se/jss.pdf) for a brief introduction into the package.\n\nIf you just want to visualize a multilevel network, then head over to my [network visualization](../netvizr/#multilevel-networks) tutorial.\n\n</details>\n\n## ... multigraphs\n\n<details>\n\n<summary>Expand</summary>\n\nMultigraphs are network representations in which multiple edges and edge loops (self edges) are permitted.\nIn R, there are at least two relevant packages. The first is `multigraph` ([link](https://CRAN.R-project.org/package=multigraph)) which implements some visualization methods for \nmultigraphs.\n\nThe second is `multigraphr` ([link](https://CRAN.R-project.org/package=multigraphr)) which comes with a\nseries of statistical methods to study local and global properties of such graphs and goodness of fit tests.\nThe [vignette](https://cran.r-project.org/web/packages/multigraphr/vignettes/multigraphr.html) of the package is\na brilliant starting point for using the package.\n\nFor the technical details behind `multigraphr`, you can refer to:\n\n>Shafie, T. (2015). A multigraph approach to social network analysis. Journal of Social Structure, 16. ([link](https://www.exeley.com/journal_of_social_structure/doi/10.21307/joss-2019-011))\n\n>Shafie, T. (2016). Analyzing local and global properties of multigraphs. The Journal of Mathematical Sociology, 40(4), 239-264. ([link](https://www.tandfonline.com/doi/abs/10.1080/0022250X.2016.1219732?journalCode=gmas20))\n\n>Shafie, T. and Schoch, D., (2021). Multiplexity analysis of networks using multigraph representations. Statistical Methods & Applications 30 (5), 1425-1444 ([link](https://link.springer.com/article/10.1007/s10260-021-00596-0))\n\n>Shafie, T. (Under review). Goodness of fit tests for random multigraph models.\n\n</details>\n\n## ... something else\n\n<details>\n\n<summary>Expand</summary>\n\nCant find what you are looking for? Ping me on [twitter](https://twitter.com/schochastics) and I see what I can do.\n\n</details>\n\n---\n\n# Loading network data into R\n\n`igraph` can deal with many different foreign network formats with the function `read_graph`.\n(The `rgexf` package can be used to import Gephi files.)\n\n\n\n::: {.cell hash='index_cache/html/read_graph_24fd8fd775454283c7ec7aa49e1f3f94'}\n\n```{.r .cell-code}\nread_graph(file, format = c(\"edgelist\", \"pajek\", \"ncol\", \"lgl\",\n  \"graphml\", \"dimacs\", \"graphdb\", \"gml\", \"dl\"), ...)\n```\n:::\n\n\n(*I personally have encountered some issue when importing `graphml` files that were \nproduced in [visone](https://visone.ethz.ch/html/about.html). Also `dl` files sometimes through an error.*)\n\nIf your network data is in one of the above formats you will find it easy to import\nyour network. \n\nIf your data is not in a network file format, you will need one of the following functions to turn raw network data into an `igraph` object:\n`graph_from_edgelist()`, `graph_from_adjacency_matrix()`, `graph_from_adj_list()`, or\n`graph_from_data_frame()`.\n\nBefore using these functions, however, you still need to get the raw data into R. The concrete procedure\ndepends on the file format. If your data is stored as an excel spreadsheet, you need additional packages.\nIf you are familiar with the `tidyverse`, you can use the `readxl` package. Other options are, e.g. the `xlsx` package.\n\nMost network data you'll find is in a plain text format (csv or tsv), either as an edgelist or adjacency matrix.\nTo read in such data, you can use base R's `read.table()`.\n\nMake sure you check the following before trying to load a file: Does it contain a header (e.g. row/column names of an adjacency matrix)? How are values delimited (comma, whitespace or tab)? This is important to set the parameters `header`, `sep` to read the data properly.\n\n\nIf you are struggling with this step, you can use the `Netreader` Rstudio add in which comes with the `snahelper` package\n\n![](Netreader1.png)\nUsing the `Netreader` should comes with a learning effect (hopefully). The last tab shows the R code to produce the network with the chosen data without using the Addin.\n\n![](Netreader2.png)\n\nSince the addin is supposed to be very general, the code might look a bit awkward.\nThe functions `graph_from_edgelist()` and `graph_from_adjacency_matrix()` come with a drawback. You can't add node or edge attributes automatically. \n\nIn general, it is always a good idea to organize network data in two different data frames. One for the nodes (with attributes)\nand one for the edges (edgelist+attributes). This will save you a lot of pain when trying to convert the \ndata into an igraph object. Especially if you want to go down the [tidy way](../tidynetanar/) later.\n\n\n\n# What is missing?\n\nI have tried to cover as many of the available packages and tools to analyze networks in R as possible \nand will include more details (and packages) over time. What I will probably never cover though are \npackages related to network dynamics, such as `ergm` or `Rsiena`. These are just not my . \nFor `ergm`, you can refer to this [statnet tutorial](http://statnet.org/Workshops/ergm_tutorial.html) and for \n`Rsiena` you can check out the [Rsiena webpage](https://www.stats.ox.ac.uk/~snijders/siena/siena_scripts.htm).\n\n---\n\n# Further Reading\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}