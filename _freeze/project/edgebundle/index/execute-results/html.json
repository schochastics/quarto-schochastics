{
  "hash": "ef8b319a15949c1cfa8735c27b5ebeb4",
  "result": {
    "markdown": "---\ndate: \"2020-12-15\"\ndescription: Implements several algorithms for bundling edges in networks and flow and metro map layouts. This includes force directed edge bundling, a flow algorithm based on Steiner trees and a multicriteria optimization method for metro map layouts.\nsubtitle: An R package implementing edgebundling techniques\ntitle: edgebundle\nimage: featured-hex.png\ntitle-block-style: none\ntoc: true\npriority: 5\n---\n\n\n<button type=\"button\" class=\"btn btn-outline-success\"><a href=\"https://github.com/schochastics/edgebundle\">GITHUB</a></button>\n\nAn R package that implements several edge bundling/flow and metro map algorithms. So far it includes\n\n- Force directed edge bundling ([paper](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.212.7989&rep=rep1&type=pdf))\n- Stub bundling ([paper](https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/NoBr13.pdf))\n- Hammer bundling ([python code](https://datashader.org/_modules/datashader/bundling.html))\n- Edge-path bundling ([paper](https://arxiv.org/abs/2108.05467))\n- TNSS flow map ([paper](https://www.tandfonline.com/doi/pdf/10.1080/15230406.2018.1437359?casa_token=1_AncPoEZ8QAAAAA:Qdl39_xDlQVCloneMFhI8rGUGgkzo6mkCMLUJThQfDs6-5J8FcmZXW4oTDqWNKQrbhL3hGEWbTY))\n- Multicriteria Metro map layout ([paper](https://ieeexplore.ieee.org/document/5406516))\n\n(The API is not very opinionated yet and may change in future releases.)\n\n## Installation\n\nThe package is available on CRAN.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"edgebundle\")\n```\n:::\n\n\nThe developer version can be installed with\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"remotes\")\nremotes::install_github(\"schochastics/edgebundle\")\n```\n:::\n\n\nNote that `edgebundle` imports `reticulate` and uses a pretty big python library (datashader).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(edgebundle)\nlibrary(igraph)\n```\n:::\n\n\n## Edge bundling\n\nThe expected input of each edge bundling function is a graph (igraph/network or tbl_graph object) and a node layout.   \nAll functions return a data frame of points along the edges of the network that can be plotted with {{ggplot2}} using `geom_path()` or\n`geom_bezier()` for `edge_bundle_stub()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\ng <- graph_from_edgelist(\n  matrix(c(1,12,2,11,3,10,4,9,5,8,6,7),ncol=2,byrow = T),F)\nxy <- cbind(c(rep(0,6),rep(1,6)),c(1:6,1:6))\n\nfbundle <- edge_bundle_force(g,xy,compatibility_threshold = 0.1)\nhead(fbundle)\n#>            x       y     index group\n#> 1 0.00000000 1.00000 0.0000000     1\n#> 2 0.00611816 1.19977 0.0303030     1\n#> 3 0.00987237 1.29767 0.0606061     1\n#> 4 0.01929293 1.52427 0.0909091     1\n#> 5 0.02790686 1.68643 0.1212121     1\n#> 6 0.03440142 1.81285 0.1515152     1\n```\n:::\n\n\nThe result can be visualized as follows.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(fbundle) +\n  geom_path(aes(x, y, group = group, col = as.factor(group)), \n            size = 2, show.legend = FALSE) +\n  geom_point(data = as.data.frame(xy), aes(V1, V2), size = 5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n\n# simple edge-path bundling example\ng <- graph_from_edgelist(matrix(c(1, 2, 1, 6, 1, 4, 2, 3, 3, 4, 4, 5, 5, 6), \n                                ncol = 2, byrow = TRUE), FALSE)\nxy <- cbind(c(0, 10, 25, 40, 50, 50), c(0, 15, 25, 15, 0, -10))\nres <- edge_bundle_path(g, xy, max_distortion = 2, weight_fac = 2, segments = 50)\n\nggplot() +\n  geom_path(data = res, aes(x, y, group = group, col = as.factor(group)), \n            size = 2, show.legend = FALSE) +\n  geom_point(data = as.data.frame(xy), aes(V1, V2), size = 5) +\n  scale_color_manual(values = c(\"grey66\", \"firebrick3\", \"firebrick3\", rep(\"grey66\", 4))) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-2.png){fig-align='center' width=672}\n:::\n:::\n\n\nFor `edge_bundle_stub()`, you need `geom_bezier()` from the package {{ggforce}}.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggforce)\ng <- graph.star(10, \"undirected\")\n\nxy <- matrix(c(\n  0, 0,\n  cos(90 * pi / 180), sin(90 * pi / 180),\n  cos(80 * pi / 180), sin(80 * pi / 180),\n  cos(70 * pi / 180), sin(70 * pi / 180),\n  cos(330 * pi / 180), sin(330 * pi / 180),\n  cos(320 * pi / 180), sin(320 * pi / 180),\n  cos(310 * pi / 180), sin(310 * pi / 180),\n  cos(210 * pi / 180), sin(210 * pi / 180),\n  cos(200 * pi / 180), sin(200 * pi / 180),\n  cos(190 * pi / 180), sin(190 * pi / 180)\n), ncol = 2, byrow = TRUE)\n\nsbundle <- edge_bundle_stub(g, xy, beta = 90)\n\nggplot(sbundle) +\n  geom_bezier(aes(x, y, group = group), size = 1.5, col = \"grey66\") +\n  geom_point(data = as.data.frame(xy), aes(V1, V2), size = 5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/bezier-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe typical edge bundling benchmark uses a dataset on us flights, which is included in the package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- us_flights\nxy <- cbind(V(g)$longitude, V(g)$latitude)\nverts <- data.frame(x = V(g)$longitude, y = V(g)$latitude)\n\nfbundle <- edge_bundle_force(g, xy, compatibility_threshold = 0.6)\nsbundle <- edge_bundle_stub(g, xy)\nhbundle <- edge_bundle_hammer(g, xy, bw = 0.7, decay = 0.5)\npbundle <- edge_bundle_path(g, xy, max_distortion = 12, weight_fac = 2, segments = 50)\n\nstates <- map_data(\"state\")\n\n\np1 <- ggplot() +\n  geom_polygon(data = states, aes(long, lat, group = group), \n               col = \"white\", size = 0.1, fill = NA) +\n  geom_path(data = fbundle, aes(x, y, group = group), \n            col = \"#9d0191\", size = 0.05) +\n  geom_path(data = fbundle, aes(x, y, group = group), \n            col = \"white\", size = 0.005) +\n  geom_point(data = verts, aes(x, y), \n             col = \"#9d0191\", size = 0.25) +\n  geom_point(data = verts, aes(x, y), \n             col = \"white\", size = 0.25, alpha = 0.5) +\n  geom_point(data = verts[verts$name != \"\", ], \n             aes(x, y), col = \"white\", size = 3, alpha = 1) +\n  labs(title = \"Force Directed Edge Bundling\") +\n  ggraph::theme_graph(background = \"black\") +\n  theme(plot.title = element_text(color = \"white\"))\n\np2 <- ggplot() +\n  geom_polygon(data = states, aes(long, lat, group = group), \n               col = \"white\", size = 0.1, fill = NA) +\n  geom_path(data = hbundle, aes(x, y, group = group), \n            col = \"#9d0191\", size = 0.05) +\n  geom_path(data = hbundle, aes(x, y, group = group), \n            col = \"white\", size = 0.005) +\n  geom_point(data = verts, aes(x, y), \n             col = \"#9d0191\", size = 0.25) +\n  geom_point(data = verts, aes(x, y), \n             col = \"white\", size = 0.25, alpha = 0.5) +\n  geom_point(data = verts[verts$name != \"\", ], aes(x, y), \n             col = \"white\", size = 3, alpha = 1) +\n  labs(title = \"Hammer Edge Bundling\") +\n  ggraph::theme_graph(background = \"black\") +\n  theme(plot.title = element_text(color = \"white\"))\n\nalpha_fct <- function(x, b = 0.01, p = 5, n = 20) {\n  (1 - b) * (2 / (n - 1))^p * abs(x - (n - 1) / 2)^p + b\n}\n\np3 <- ggplot() +\n  geom_polygon(data = states, aes(long, lat, group = group), \n               col = \"white\", size = 0.1, fill = NA) +\n  ggforce::geom_bezier(\n    data = sbundle, aes(x, y,\n      group = group,\n      alpha = alpha_fct(..index.. * 20)\n    ), n = 20,\n    col = \"#9d0191\", size = 0.1, show.legend = FALSE\n  ) +\n  ggforce::geom_bezier(\n    data = sbundle, aes(x, y,\n      group = group,\n      alpha = alpha_fct(..index.. * 20)\n    ), n = 20,\n    col = \"white\", size = 0.01, show.legend = FALSE\n  ) +\n  geom_point(data = verts, aes(x, y), \n             col = \"#9d0191\", size = 0.25) +\n  geom_point(data = verts, aes(x, y), \n             col = \"white\", size = 0.25, alpha = 0.5) +\n  geom_point(data = verts[verts$name != \"\", ], aes(x, y), \n             col = \"white\", size = 3, alpha = 1) +\n  labs(title = \"Stub Edge Bundling\") +\n  ggraph::theme_graph(background = \"black\") +\n  theme(plot.title = element_text(color = \"white\"))\n\np4 <- ggplot() +\n  geom_polygon(data = states, aes(long, lat, group = group), \n               col = \"white\", size = 0.1, fill = NA) +\n  geom_path(data = pbundle, aes(x, y, group = group), \n            col = \"#9d0191\", size = 0.05) +\n  geom_path(data = pbundle, aes(x, y, group = group), \n            col = \"white\", size = 0.005) +\n  geom_point(data = verts, aes(x, y), \n             col = \"#9d0191\", size = 0.25) +\n  geom_point(data = verts, aes(x, y), \n             col = \"white\", size = 0.25, alpha = 0.5) +\n  geom_point(data = verts[verts$name != \"\", ], aes(x, y), \n             col = \"white\", size = 3, alpha = 1) +\n  labs(title = \"Edge-Path Bundling\") +\n  ggraph::theme_graph(background = \"black\") +\n  theme(plot.title = element_text(color = \"white\"))\n\np1\np2\np3\np4\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/flights_fdeb.png){fig-align='center' width=95%}\n:::\n\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/flights_heb.png){fig-align='center' width=95%}\n:::\n\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/flights_seb.png){fig-align='center' width=95%}\n:::\n\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/flights_peb.png){fig-align='center' width=95%}\n:::\n:::\n\n\n\n## Flow maps\n\nA flow map is a type of thematic map that represent movements. It may thus be considered a hybrid of a map and a flow diagram.\nThe package so far implements a spatial one-to-many flow layout algorithm using\ntriangulation and approximate Steiner trees.\n\nThe function `tnss_tree()` expects a one-to-many flow network (i.e. a weighted star graph), a layout for the nodes and\na set of dummy nodes created with `tnss_dummies()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggraph)\nxy <- cbind(state.center$x,state.center$y)[!state.name%in%c(\"Alaska\",\"Hawaii\"),]\nxy_dummy <- tnss_dummies(xy,4)\ngtree <- tnss_tree(cali2010,xy,xy_dummy,4,gamma = 0.9)\n\nggraph(gtree,\"manual\",x=V(gtree)$x,y=V(gtree)$y)+\n  geom_polygon(data=us,aes(long,lat,group=group),fill=\"#FDF8C7\",col=\"black\")+\n  geom_edge_link(aes(width=flow,col=sqrt((xy[root,1]-..x..)^2 + (xy[root,2]-..y..)^2)),\n                 lineend = \"round\",show.legend = FALSE)+\n  scale_edge_width(range=c(0.5,4),trans=\"sqrt\")+\n  scale_edge_color_gradient(low=\"#cc0000\",high = \"#0000cc\")+\n  geom_node_point(aes(filter=tnss==\"leaf\"),size=1)+\n  geom_node_point(aes(filter=(name==\"California\")),size=5,shape=22,fill=\"#cc0000\")+\n  theme_graph()+\n  labs(title=\"Migration from California (2010) - Flow map\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/cali2010_flow.png){fig-align='center' width=95%}\n:::\n:::\n\n\nTo smooth the tree, use `tnss_smooth()`. Note that this changes the object type and\nyou need to visualize it with {{ggplot2}} rather than {{ggraph}}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmooth_df <- tnss_smooth(gtree,bw=5,n=20)\n\nggplot()+\n  geom_polygon(data=us,aes(long,lat,group=group),fill=\"#FDF8C7\",col=\"black\")+\n  geom_path(data = smooth_df,aes(x,y,group=destination,size=flow),\n            lineend = \"round\",col=\"firebrick3\",alpha=1)+\n  theme_void()+\n  scale_size(range=c(0.5,3),guide = \"none\")+\n  labs(title=\"Migration from California (2010) - Flow map smoothed\")\n\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/cali2010_flow_smoothed.png){fig-align='center' width=95%}\n:::\n:::\n\n\n## Metro Maps\n\nMetro map(-like) graph drawing follow certain rules, such as octilinear edges. The algorithm\nimplemented in the packages uses hill-climbing to optimize several features desired in a metro map.\nThe package includes the metro map of Berlin as an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\n# the algorithm has problems with parallel edges\ng <- simplify(metro_berlin)\nxy <- cbind(V(g)$lon,V(g)$lat)*100\n\n# the algorithm is not very stable. try playing with the parameters\nxy_new <- metro_multicriteria(g,xy,l = 2,gr = 0.5,w = c(100,100,1,1,100),bsize = 35)\n\n# geographic layout\nggraph(metro_berlin,\"manual\",x=xy[,1],y=xy[,2])+\n  geom_edge_link0(aes(col=route_I_counts),edge_width=2,show.legend = FALSE)+\n  geom_node_point(shape=21,col=\"white\",fill=\"black\",size=3,stroke=0.5)\n\n#schematic layout\nggraph(metro_berlin,\"manual\",x=xy_new[,1],y=xy_new[,2])+\n  geom_edge_link0(aes(col=route_I_counts),edge_width=2,show.legend = FALSE)+\n  geom_node_point(shape=21,col=\"white\",fill=\"black\",size=3,stroke=0.5)+\n  theme_graph()+\n  labs(title = \"Subway Network Berlin\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/schochastics/edgebundle/main/man/figures/metro_berlin.png){fig-align='center' width=95%}\n:::\n:::\n\n\n## Disclaimer\n\nEdge bundling is able to produce neat looking network visualizations. However, they do not \nnecessarily enhance readability. After experimenting with several methods, it became quite\nevident that the algorithms are very sensitive to the parameter settings (and often really only work in the showcase examples...). Consult the original literature (if they even provide any guidelines) or experiment yourself and **do not expect any miracles**.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}