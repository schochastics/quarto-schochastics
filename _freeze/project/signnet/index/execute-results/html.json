{
  "hash": "6532b798c2985ac38a8d86d9b3299b86",
  "result": {
    "markdown": "---\nauthor: David Schoch\ndate: \"2019-08-14\"\ndescription: Implements methods for the analysis of signed networks. This includes several measures for structural balance, blockmodeling algorithms, various centrality indices, and projections of signed two-mode networks.\nsubtitle: An R package for signed network analysis\ntitle: signnet\nimage: featured-hex.png\ntitle-block-style: none\ntoc: true\npriority: 6\n---\n\n\n<button type=\"button\" class=\"btn btn-outline-success\"><a href=\"https://github.com/schochastics/signnet\">GITHUB</a></button>\n<button type=\"button\" class=\"btn btn-outline-success\"><a href=\"http://signnet.schochastics.net/\">PKGDOWN</a></button>\n\n\n\n\n\n\nThe package provides methods to analyse signed networks (i.e. networks with both positive and negative ties).\n\n## Installation\n\nYou can install the released version of signnet from CRAN with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"signnet\")\n```\n:::\n\n\nThe development version from is available with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"devtools\")\ndevtools::install_github(\"schochastics/signnet\")\n```\n:::\n\n\n## Structural Balance and Triads\n\nThe principles underlying structural balance are based on a theory in social psychology dating back to the work of Heider in the 1940s, which was generalized and extended to graphs by Cartwright and Harary in the 1950s. In its simplest form, it is defined via triangles. A triangle is balanced if\nall ties are positive (\"the friend of a friend is a friend\") or only one tie is positive (\"the enemy of my enemy is my friend\"). The remaining configurations are said to be unbalanced.\n\n<img src=\"https://raw.githubusercontent.com/schochastics/signnet/master/man/figures/balance_triples.png\"/>\n\nA network is balanced if i.a., it can be partitioned into two vertex subsets, such that intra-group edges are all positive and inter-group edges are all negative. Determining this is easy, but measuring a *degree of balancedness* (i.e. how close is a network to be balanced?) is not. The package, so far, implements three methods to calculate balance scores. All are defined such that a value of one indicates perfect balance and zero perfect unbalance. Though for intermediate networks, results may vary significantly. Check [this paper](https://doi.org/10.1093/comnet/cnx044) by Samin Aref (and his other work) for more details.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(signnet)\ndata(\"tribes\")\n\nbalance_score(tribes,method = \"triangles\")\n#> [1] 0.867647\nbalance_score(tribes,method = \"walk\")\n#> [1] 0.357576\nbalance_score(tribes,method = \"frustration\")\n#> [1] 0.758621\n```\n:::\n\n\nFor directed signed networks, `triad_census_signed()` can be used to compute the count for all 138 non-isomorphic signed triads.\n<img src=\"https://raw.githubusercontent.com/schochastics/signnet/master/man/figures/signed_triads.png\">\n\n# Blockmodeling\n\nThe package implements two different blockmodeling algorithms. The classic one tries to partition the \nnetwork into a specified set of groups such that intra group edges are positive and inter group edges are negative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclu <- signed_blockmodel(tribes,k = 3,alpha = 0.5,annealing = TRUE)\nclu\n#> $membership\n#>  [1] 2 2 3 3 1 3 3 3 1 1 3 3 1 1 2 2\n#> \n#> $criterion\n#> [1] 2\n```\n:::\n\n\nThe parameter *k* is the number of groups and *alpha* specifies the penalty of negative inter group and positive intra group edges.\nIf `alpha = 0` (`alpha = 1`) then only positive inter group (negative intra group) edges are penalized. Set `alpha = 0.5` for equal penalization\nThe algorithm is not exact and just a heuristic. If `annealing = TRUE`, then simulated annealing is used. This improves the result, but may take additional time.\n\nThe result of the blockmodel can be visualized with `ggblock` (requires `ggplot2`)\n\n::: {.cell}\n\n```{.r .cell-code}\nggblock(tribes,clu$membership,show_blocks = TRUE,show_labels = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/block_example-1.png){width=100%}\n:::\n:::\n\n\n\nThe second blockmodeling technique is known as *generalized blockmodeling*. This method removes the restriction of positve (negative) inter (intra) group edges. Instead, a blockmatrix is passed to the function with the desired block structure. The example below illustrates the technique with a network composed of three groups with differing inter/intra group edge patterns.\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a signed network with three groups and different inter/intra group ties\ng1 <- g2 <- g3 <- graph.full(5)\n\nV(g1)$name <- as.character(1:5)\nV(g2)$name <- as.character(6:10)\nV(g3)$name <- as.character(11:15)\n\ng <- Reduce(\"%u%\",list(g1,g2,g3))\nE(g)$sign <- 1\nE(g)$sign[1:10] <- -1\ng <- add.edges(g,c(rbind(1:5,6:10)),attr = list(sign=-1))\ng <- add.edges(g,c(rbind(1:5,11:15)),attr = list(sign=-1))\ng <- add.edges(g,c(rbind(11:15,6:10)),attr = list(sign=1))\n\n# specify the link patterns between groups\nblockmat <- matrix(c(1,-1,-1,-1,1,1,-1,1,-1),3,3,byrow = TRUE)\nblockmat\n#>      [,1] [,2] [,3]\n#> [1,]    1   -1   -1\n#> [2,]   -1    1    1\n#> [3,]   -1    1   -1\n\nclu <- signed_blockmodel_general(g,blockmat,0.5)\nclu\n#> $membership\n#>  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\n#> \n#> $criterion\n#> [1] 0\nggblock(g,clu$membership,show_blocks = TRUE,show_labels = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/general_example-1.png){width=100%}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}